---
title: "JVM 内存分代与垃圾回收 (GC) 机制详解"
date: 2024-04-24T15:00:00+08:00 # 请将日期更新为今天的日期
draft: false
author: "OnClickListener" # 可以替换成你的名字
authorLink: ""
weight: 1 # 可选，用于排序
description: "深入解析 Java 虚拟机 (JVM) 的内存分代模型（新生代、老年代、元空间）及其核心的垃圾回收 (GC) 机制、算法和常见收集器。"
license: ""
resources: # 可选：添加特色图片或其他资源
- name: "featured-image"
  src: "featured-image.png" # 比如添加一张流程图
tags: ["JVM", "内存管理", "垃圾回收", "GC", "Java", "分代", "算法", "收集器"]
categories: ["技术原理"]

featuredImage: ""
featuredImagePreview: ""

hiddenFromHomePage: false
hiddenFromSearch: false
twemoji: false
lightgallery: true
ruby: true
fraction: true
fontawesome: true
linkToMarkdown: true
rssFullText: false

toc:
  enable: true
  auto: true
code:
  copy: true
  maxShownLines: 50
math:
  enable: false
mapbox:
  # ... (mapbox options if needed)
share:
  enable: true
comment:
  enable: true
library:
  css:
    # Add specific CSS files if needed
  js:
    # Add specific JS files if needed
seo:
  images: []
---

## 引言：为何需要理解 JVM 内存与 GC

Java 语言的一大优势在于其**自动内存管理**机制，开发者无需像 C/C++ 那样手动分配和释放内存。这背后的功臣就是 **JVM 的垃圾回收 (Garbage Collection, GC)** 机制。理解 JVM 的内存布局（分代）和 GC 如何工作，对于编写高性能、稳定的 Java 应用至关重要，也是排查内存泄漏、OOM 等问题的基础。

> 本文将首先回顾 JVM 的内存分代模型，然后深入探讨 GC 的核心机制、常用算法以及常见的垃圾收集器。

---

## 第一部分：JVM 内存分代模型回顾

（*这里承接上一篇的内容，为保持完整性，简要重述核心点*）

JVM 将堆内存划分为不同的**代 (Generation)**，主要是为了**优化 GC 效率**，基于“大部分对象朝生夕死”的假设。

### 1. 新生代 (Young Generation)

*   **组成:** Eden 区 + 两个 Survivor 区 (S0, S1)
*   **特点:** 存放新创建的对象，生命周期短。
*   **GC 类型:** **Minor GC / Young GC** (频繁，速度快，使用**复制算法**)
*   **晋升:** 对象在 Survivor 区经历多次 GC 后，达到年龄阈值会晋升到老年代。

### 2. 老年代 (Old Generation)

*   **组成:** 单一区域
*   **特点:** 存放生命周期长的对象或大对象。
*   **GC 类型:** **Major GC / Full GC** (频率低，耗时长，通常使用**标记-清除**或**标记-整理**算法)

### 3. (非堆区) 元空间 (Metaspace) / 永久代 (PermGen)

*   **用途:** 存储类元数据、常量池等。
*   **演进:** JDK 8 用元空间 (本地内存) 替代了永久代 (堆内)。
*   **GC:** 其空间不足也可能触发 GC (尤其是 Full GC)。

---

## 第二部分：JVM 垃圾回收 (GC) 机制

GC 的核心任务是**识别不再被使用的对象 (垃圾)** 并**回收它们占用的内存空间**。

### 1. 如何判断对象是否存活？

JVM 主要采用 **可达性分析 (Reachability Analysis)** 算法来判断对象是否存活。

*   **基本思路:**
    1.  从一系列称为 **"GC Roots"** 的根对象开始向下搜索。
    2.  搜索走过的路径称为**引用链 (Reference Chain)**。
    3.  如果一个对象到任何 GC Roots 都没有引用链相连，则证明此对象是**不可达**的，即为**垃圾对象**。
*   **常见的 GC Roots:**
    *   虚拟机栈 (栈帧中的本地变量表) 中引用的对象。
    *   方法区中类静态属性引用的对象。
    *   方法区中常量引用的对象。
    *   本地方法栈中 JNI (即 Native 方法) 引用的对象。
    *   JVM 内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象等。
    *   被同步锁 (synchronized 关键字) 持有的对象。

{{< admonition type=info title="可达性分析" open=true >}}
可以想象成一个图，GC Roots 是起点，对象是节点，引用是边。从起点出发能走到的节点都是存活对象，走不到的就是垃圾。
{{< /admonition >}}

### 2. 常见的垃圾回收算法

在确定了哪些是垃圾对象后，就需要用具体的算法来回收内存。

#### a. 标记-清除 (Mark-Sweep)

*   **过程:**
    1.  **标记 (Mark):** 从 GC Roots 开始遍历，标记所有存活的对象。
    2.  **清除 (Sweep):** 遍历整个堆，回收未被标记的（即垃圾）对象所占用的内存。
*   **优点:** 实现简单，不需要移动对象。
*   **缺点:**
    *   **效率问题:** 标记和清除两个过程效率都不算高。
    *   **空间问题 (内存碎片):** 清除后会产生大量不连续的内存碎片，可能导致后续无法为大对象分配足够连续的空间而提前触发下一次 GC。

#### b. 复制 (Copying)

*   **过程:**
    1.  将内存划分为**大小相等**的两块，每次只使用其中一块 (例如 A 区)。
    2.  当 A 区内存用完时，触发 GC。
    3.  将 A 区中**存活的对象**复制到另一块**空的内存区域** (B 区)。
    4.  一次性清空 A 区的所有内存。
    5.  之后 B 区变成使用区，A 区变成空闲区，角色互换。
*   **优点:**
    *   实现简单，运行高效（只需复制存活对象）。
    *   **不会产生内存碎片**，内存分配时只需移动指针即可。
*   **缺点:**
    *   **空间浪费:** 可用内存缩小为原来的一半。
    *   如果存活对象很多，复制开销会很大。
*   **应用:** 主要用于**新生代**的垃圾回收 (Eden 和 Survivor 区)。因为新生代对象存活率低，复制成本相对较低。Survivor 区就是对纯粹复制算法的优化，只浪费了少量 Survivor 空间。

#### c. 标记-整理 (Mark-Compact)

*   **过程:**
    1.  **标记 (Mark):** 同标记-清除算法，标记所有存活对象。
    2.  **整理 (Compact):** **移动**所有存活的对象，让他们都向内存空间的一端移动，然后直接清理掉边界以外的内存。
*   **优点:**
    *   **解决了内存碎片问题**。
    *   不像复制算法那样浪费一半空间。
*   **缺点:**
    *   标记和清除的效率问题依然存在。
    *   **移动对象成本高:** 需要更新所有指向这些对象的引用，是一个比较耗时的操作，需要暂停用户线程 (Stop-The-World)。
*   **应用:** 主要用于**老年代**的垃圾回收。

{{< admonition type=tip title="分代收集策略" open=true >}}
现代 JVM 的**分代收集 (Generational Collection)** 策略，并不是一种具体的算法，而是**基于不同代的特点选用不同算法的组合**：
*   **新生代 (存活率低):** 选用**复制算法** (Minor GC)。
*   **老年代 (存活率高，对象多):** 选用**标记-清除**或**标记-整理**算法 (Major GC / Full GC)。
{{< /admonition >}}

### 3. 关键概念

*   **Stop-The-World (STW):** 为了进行垃圾回收，JVM 必须暂停所有用户执行线程的现象。GC 优化的一个主要目标就是减少 STW 的时间和频率。
*   **Safepoint (安全点):** 用户线程并非可以在任意指令处暂停，而是在预先设定好的“安全点”才能暂停以进行 GC。安全点通常选在方法调用、循环跳转、异常抛出等地方。
*   **Safe Region (安全区域):** 指在一段代码片段中，引用关系不会发生变化。在这个区域内的线程即使没有运行到 Safepoint，也可以被认为是可以安全地开始 GC 的。这主要用于处理长时间阻塞或休眠的线程。

### 4. 常见的垃圾收集器 (GC Collectors)

GC 算法是理论，而垃圾收集器是这些算法的具体实现。不同的收集器有不同的特性和适用场景。

*   **Serial / Serial Old:**
    *   单线程收集器。GC 时只有一个 CPU 或一条 GC 线程工作，且必须 STW。
    *   简单高效 (对于单核 CPU 或小内存环境)。
    *   新生代用 Serial (复制算法)，老年代用 Serial Old (标记-整理)。
    *   适用于客户端模式或内存较小的应用。
*   **Parallel Scavenge / Parallel Old (JDK 8 默认):**
    *   **吞吐量优先**收集器。多线程进行 GC，能有效缩短 STW 时间。
    *   新生代用 Parallel Scavenge (复制算法)，老年代用 Parallel Old (标记-整理)。
    *   关注点在于达到一个可控的吞吐量 (CPU 用于运行用户代码的时间 / (CPU 运行用户代码时间 + CPU 垃圾收集时间))。
    *   适用于后台计算、数据处理等对吞吐量要求高、对停顿时间不太敏感的应用。
*   **ParNew:**
    *   Serial 收集器的多线程版本 (新生代，复制算法)。
    *   常与 **CMS** 收集器配合使用。
*   **CMS (Concurrent Mark Sweep):**
    *   **低停顿**为目标的收集器 (老年代，基于**标记-清除**)。
    *   特点是 GC 过程中的**并发标记**和**并发清除**阶段可以与用户线程一起工作，大大缩短了 STW 时间。
    *   **缺点:**
        *   对 CPU 资源敏感 (并发阶段会抢占用户线程资源)。
        *   无法处理**浮动垃圾** (并发清理阶段产生的新垃圾)。
        *   基于标记-清除导致**内存碎片**，可能触发 Full GC。
    *   适用于对响应时间有较高要求的互联网应用、B/S 系统服务端。
*   **G1 (Garbage-First):**
    *   **面向服务端应用**的收集器，试图**平衡吞吐量和低停顿**。
    *   **特点:**
        *   **分代，但不要求连续:** 将堆划分为多个大小相等的独立区域 (Region)，每个 Region 可以是 Eden、Survivor 或 Old。
        *   **空间整合:** 整体基于“标记-整理”，局部（Region 之间）基于“复制”，**不会产生内存碎片**。
        *   **可预测的停顿时间模型:** 允许用户指定期望的最大 GC 停顿时间 ( `-XX:MaxGCPauseMillis` )，G1 会尽力满足。它通过优先回收价值最大（垃圾最多）的 Region 来实现。
    *   JDK 9 及以后的默认收集器。
*   **ZGC / Shenandoah:**
    *   **追求极低停顿**的收集器 (目标是毫秒级甚至亚毫秒级 STW)。
    *   使用了更复杂的并发技术 (如着色指针、读屏障等)。
    *   适用于超大内存、对延迟极度敏感的应用。

{{< admonition type=warning title="选择合适的收集器" open=true >}}
没有万能的 GC 收集器。选择哪种收集器需要根据应用的特性 (内存大小、CPU 核心数、对吞吐量和延迟的要求) 进行测试和调优。
{{< /admonition >}}

---

## 总结

*   JVM 通过**分代内存管理**优化 GC 性能，新生代使用 Minor GC (复制算法)，老年代使用 Major GC/Full GC (标记-清除/整理算法)。
*   GC 通过**可达性分析**识别垃圾对象。
*   核心 GC 算法包括**标记-清除**、**复制**、**标记-整理**。
*   JVM 提供了多种**垃圾收集器**实现，各有优劣，适用于不同场景 (Serial, Parallel, CMS, G1, ZGC等)。
*   理解 GC 机制有助于进行**性能调优**，避免**内存泄漏**和 **OOM** 问题，并选择最适合应用的 GC 策略。
